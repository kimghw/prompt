# 1. 목표 설정 및 유즈-시나리오 초안 (개인 작성)
---
## 1.1 목표 설정
### ▸ 달성하고자 하는 최종 목표
- 예) **사내 이메일·PDF 문서를 벡터 DB에 임베딩하여 자연어 검색 서비스를 제공**

### ▸ 목표의 성공 기준(예시)
- 예) **Top-3 정답률 ≥ 85 %** (파일 20 만 개 테스트)
- 질의-응답 평균 지연 ≤ 1 초
- 월간 유지보수 시간 < 4 시간
---
## 1.2 핵심 요구사항(예시)
### ▸ 기능 요구사항 (Functionals)
1. **문서 수집**  
   - 이메일 API 수신, PDF 업로드, 폴더 워치 등
2. **텍스트 추출 & 청크 분할**
3. **임베딩 생성 및 벡터 DB 저장**
   1. 다양한 라이브러리 및 외부 API 임베딩 모델 사용
4. **자연어 질의 → k-NN 검색 → 답변 생성**
5. **관리 대시보드** (통계·로그 모니터링)
6. **백업·복구** 자동화

### ▸ 비-기능 요구사항 (Non-functionals)(예시)
- **성능** : 평균 지연 1 s 이내, 동시 100 QPS 처리
- **보안** : OAuth2 인증, 전 구간 TLS, S3 서버-사이드 암호화
- **사용성** : 모바일-퍼스트 UI, 검색창 1 초 자동완성
- **확장성** : 워커·검색 노드 수평 스케일
- **가용성** : 99.9 % SLA, 무중단 배포 (blue/green)

### ▸ 우선순위 설정(예시)
| Priority | 요구사항                         |
|----------|----------------------------------|
| **P0**   | 문서 수집, 임베딩 저장, 검색 API |
| **P1**   | 관리 대시보드, 로그 집계         |
| **P2**   | 모바일 UI, 고급 필터 검색        |

---

## 1.3 유즈케이스 초안 (예시)
### ▸ 사용자 흐름 (스토리 방식)
> **“정보를 찾으려는 직원 A”**  
> 1) 웹 검색창에 질문 입력 →  
> 2) 시스템이 벡터 검색으로 관련 문서를 3 개 선정 →  
> 3) 요약 답변 + 문서 링크 표시 →  
> 4) 직원 A가 문서 상세 열람

### ▸ 단계별 스텝 (예시)
1. **초기화** : 사용자 JWT 검증
2. **질의 전처리** : 언어 감지·정규화
3. **k-NN 검색** : 임베딩 → 벡터 DB
4. **후처리** : 랭킹, 스니펫 생성
5. **응답 전송** : JSON + 렌더링

### ▸ 예외 / 대안 흐름 (예시)
- **E-1** : 토큰 만료 → 로그인 재요청
- **E-2** : 검색 결과 0 건 → “유사 질문” 추천

### ▸ 사전 조건 (예시)
- 사용자는 사내 SSO로 인증 완료
- 문서가 사전에 임베딩되어 있음

### ▸ 사후 조건 (예시)
- 질의·응답 로그가 분석 스토리지에 저장
- FAQ 모델 학습을 위해 피드백(👍/👎) 데이터 적재


## 2. 유즈케이스 작성 기준 (간단/보완 버전)

### 2.1 Atomic 유즈케이스

1. **하나의 비즈니스 목표(사용자 동기)를 가진다.**  
   - 예) “회원가입”, “주문 생성”, “인증 토큰 발급” 등

2. **비즈니스 로직이 순수하게 들어있다.**  
   - 단순 CRUD를 넘어서는 업무 규칙, 예외 처리, 트랜잭션, 보안, 비동기 처리 등이 포함될 수 있음

3. **트랜잭션(데이터 일관성), API 호출, 비동기(웹훅) 고려 여부**  
   - 유즈케이스 내부에 둘 이상의 중요 요소(예: Transaction, Async, Recovery, Security, Reuse)가 있다면  
     별도의 유즈케이스로 분리할 만한 복잡도로 판단

4. **단독 실행 가능 & 재사용 가능 여부**  
   - 여러 군데에서 공통으로 쓰이면 분리(아토믹 유즈케이스)하는 것이 유리  
   - 재사용 가능성이 거의 없고 지나치게 단순하면 유즈케이스 대신 **함수나 서비스 메서드**로 처리할 수도 있음

5. **시나리오가 너무 복잡**  
   - 하나의 유즈케이스가 지나치게 길거나 복잡하면, 적절히 쪼개서 (A→B→C) 형태로 나눌 수 있음

### 2.2 Composite 유즈케이스

1. **여러 아토믹 유즈케이스를 묶어 하나의 큰 시나리오를 구성**  
   - 예) “회원가입” + “외부 인증” + “토큰 저장” 등

2. **최상위 시나리오에서 단계별 연결 관계를 간단히 정리**  
   - 예)  
     1) 계정 생성(아토믹 UC)  
     2) 인증 API 호출(아토믹 UC)  
     3) 토큰 수신 및 DB 저장(아토믹 UC)

3. **단일 유즈케이스로 보기는 너무 크거나, 복합적인 플로우가 있는 경우**  
   - 이때, “컴포짓 유즈케이스” 문서에서 각 아토믹 유즈케이스의 실행 순서와 예외처리를 연결 지어 표현

### 2.3 단순 기능 처리

1. **단순 CRUD는 유즈케이스에서 제외**  
   - CRUD가 하나의 흐름(복잡한 로직)으로 연결되면 컴포짓 유즈케이스의 일부 단계나 일반적인 함수/메서드로 처리

2. **단순 호출·데이터 변환·필터링**  
   - 유즈케이스보다는 **함수(메서드)**나 **서비스 레벨**로 구현 권장  
   - 예) “이메일 주소 포맷 검사”, “단순 로그 남기기” 등은 굳이 유즈케이스로 안 만든다

3. **포트·어댑터(또는 함수)로 구현**  
   - 굳이 독립 유즈케이스로 보기엔 너무 작은 기능들은 **포트/어댑터**나 **도메인 서비스** 안의 메서드로 처리



## 3. 유즈케이스 문서 작성 기준
## 1.1. 공통 사항
1. **유즈케이스 식별 및 ID 부여**  
   - 각 유즈케이스에는 고유 ID(예: `UC-1`, `UC-2`)를 부여합니다.  
   - 간단한 **이름**과 **한 줄 설명**을 통해 유즈케이스를 식별하기 쉽게 작성합니다.

2. **목적/범위 명시**  
   - 각 유즈케이스가 제공하는 비즈니스 가치(목적)를 짧고 명확하게 제시합니다.  
   - 범위(Scope)를 설정하여, 유즈케이스에 포함·제외되는 기능(혹은 액터) 구분을 명확히 합니다.

3. **액터(Actor) 구분**  
   - 실제 유즈케이스에 관여하는 사용자(직원, 고객 등)나 외부 시스템(API) 등을 액터로 정의합니다.  
   - 액터 간 상호작용을 표나 다이어그램으로 간략하게 표현할 수도 있습니다.

4. **연관된 요구사항 매핑**  
   - (있는 경우) 요구사항 명세서와 연결될 수 있도록 요구사항 ID를 기재합니다.  
   - 예) "UC-3 → FR-05(문서 검색 기능)”

---

## 2. 요약 문서(Brief / Overview) 작성 기준

1. **전체 유즈케이스 목록 나열**  
   - 유즈케이스 이름, 간단 설명(목적), 주요 액터, 입력/출력(요약)  
   - 트랜잭션/외부 API/비동기 여부 등 중요한 사항을 간단히 표기합니다.

2. **우선순위(Priority)와 구현 시점**  
   - 유즈케이스마다 중요도(P0, P1, P2 등)를 표기하고,  
   - 구현할 시점(개발 일정, 마일스톤)을 대략적으로 명시할 수 있습니다.

3. **연관 관계(Dependency) 표시**  
   - 유즈케이스 간 의존성(예: UC-2가 UC-1의 결과를 사용)  
   - 외부 API 연동, 데이터 플로우(업로드 → 임베딩 → 검색) 등을 한눈에 파악할 수 있게 정리합니다.

**예시 표**

| Use Case ID | Use Case 명      | 간단 설명                       | 액터     | 우선순위 | 비고             |
|-------------|------------------|---------------------------------|----------|---------|------------------|
| UC-1        | 문서 업로드       | 사용자가 PDF 파일을 업로드       | 직원 A   | P0      | 트랜잭션 발생     |
| UC-2        | 벡터 임베딩 생성   | PDF 텍스트 추출 후 임베딩 생성    | 시스템 B | P0      | 외부 API 사용     |
| UC-3        | 검색 결과 조회     | 사용자 검색 요청 후 k-NN 검색 수행 | 직원 A   | P1      | 실시간 처리       |
| UC-4        | 답변 생성        | 검색 결과에 대해 요약·추론 답변    | 시스템 B | P1      | 비동기 호출 있음  |

---

## 3. 상세 문서(Detailed Use Case) 작성 기준

1. **기본 정보**  
   - **유즈케이스 명**: 간단명료하게 작성  
   - **설명(목적)**: 해당 유즈케이스가 해결하고자 하는 문제나 제공하는 가치  
   - **액터**: 사용자, 외부 시스템 등  
   - **연관 요구사항 ID**: 요구사항 문서와의 연결 고리

2. **흐름 정의(Flow)**  
   - **메인 시나리오(Main Flow)**  
     - 정상적으로 처리되는 단계별 흐름(1 → 2 → 3 …)  
     - 예) 사용자가 요청 → 시스템 처리 → 사용자에게 결과  
   - **대안 흐름(Alternative Flow)**  
     - 특정 조건에서 달라지는 흐름(옵션 사용, 파라미터 조건 등)  
   - **예외 흐름(Exception Flow)**  
     - 에러 상황이나 유효성 검증 실패 시 처리 로직(에러 메시지, 재시도, 롤백 등)

3. **입력/출력**  
   - **입력 파라미터**: 필드명, 타입, 필수/옵션 여부, 유효성 조건  
   - **출력 데이터**: 성공 시 반환 데이터 구조, 에러 시 에러 코드/메시지 등

4. **트랜잭션 범위**  
   - DB나 외부 API와 상호작용 시 트랜잭션이 언제 시작되고 끝나는지 명시  
   - 재시도 또는 롤백 전략, 타임아웃 등도 이 항목에 기술

5. **시스템/사용자 간 인터랙션**  
   - 인증(SSO, JWT), 세션 처리, 시스템 간 동기/비동기 호출  
   - 필요 시 시퀀스 다이어그램 또는 액티비티 다이어그램으로 시각화

6. **사전 조건(Pre-Condition)/사후 조건(Post-Condition)**  
   - **사전 조건**: 유즈케이스가 실행되기 위해 사전에 충족되어야 할 상태 또는 데이터(예: 로그인, 사전 등록된 정보 등)  
   - **사후 조건**: 유즈케이스 실행 후 변경되는 상태나 결과(예: DB에 데이터 추가, 로그 기록 등)

**예시 템플릿**

> **UC-3: 검색 결과 조회**  
> 
> **1) 기본 정보**  
> - 목적 : 사용자가 검색어를 입력 → k-NN 검색으로 관련 문서 목록을 반환  
> - 액터 : 직원 A  
> - 연관 요구사항 : [FR-02], [NF-01]  
>
> **2) 메인 시나리오**  
> 1) 직원 A가 웹 검색창에 질의문 입력 후 검색 버튼 클릭  
> 2) 시스템이 JWT 토큰을 검증  
> 3) 질의를 임베딩 → 벡터 DB에 k-NN 검색 요청  
> 4) 상위 3개 문서를 반환  
> 5) 결과를 JSON 형태로 클라이언트에 전달  
>
> **3) 대안 흐름**  
> - A-1 : 검색어가 비어있음 → “검색어를 입력하세요” 안내  
> - A-2 : 벡터 DB 연결 지연 → 재시도 후 실패 시 에러 화면  
>
> **4) 예외 흐름**  
> - E-1 : JWT 토큰 만료 → 로그인 페이지로 이동  
>
> **5) 입력/출력**  
> - 입력 : 검색어(String), JWT 토큰  
> - 출력 : 문서 목록(JSON), 에러 시 에러 메시지  
>
> **6) 트랜잭션 범위**  
> - 벡터 DB 호출 시 오류 발생하면 재시도(1회), 재시도 실패 시 에러 반환  
>
> **7) 사전 조건/사후 조건**  
> - **사전 조건** : SSO 로그인 상태, 문서 임베딩 사전 완료  
> - **사후 조건** : 검색 로그 저장, 검색 결과 화면 표시  








