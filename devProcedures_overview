# 소프트웨어 개발 절차

## 1. 목표/기능 요구사항 도출

## 2. 유즈케이스 작성

## 3. 유즈케이스 우선순위 결정

## 4. 개발 진행

### 4.1 프로젝트 구성
1. **개발환경 결정**  
   - IDE, 에디터, OS, 프레임워크 버전, 빌드 도구(Maven/Gradle/npm 등)  
2. **프로젝트 아키텍처 결정**  
   - 모놀리식(Monolithic) 또는 마이크로서비스(Microservices) 등  
   - 레이어드 아키텍처(Controller-Service-Repository) 또는 DDD 구조(Domain-Application-Infrastructure)  
3. **관련 라이브러리, DB, API 결정**  
   - 예) Spring Boot, React, MySQL, Redis, 외부 결제 API 등  
   - 빌드/패키지 도구 설정(Maven, Gradle 등)  
4. **Git 브랜치 전략 결정 / 유즈케이스별 브랜치 생성**  
   - Git Flow, GitHub Flow, Trunk-Based Development 등  
   - 예) `develop`(공통코드/통합용) 브랜치 기반으로 각 유즈케이스마다 `feature/{usecase_name}` 브랜치 생성

### 4.2 시나리오별 단위 개발
#### 4.2.1 우선순위 결정
- 우선순위가 높은 유즈케이스(시나리오)부터 **개발 브랜치**를 생성하여 진행  
- 스프린트 또는 칸반 보드를 통해 개발 단계를 시각적으로 관리  

#### 4.2.2 설계 및 모델링
1. **UI/UX 설계**  
   - 와이어프레임, 프로토타입, 사용자 플로우 등  
2. **데이터 모델 설계**  
   - 데이터베이스 스키마, 테이블 구조, 엔티티(객체) 관계 설정  
3. **업무 로직 설계**  
   - 유즈케이스별 프로세스, 비즈니스 규칙, 예외 상황 처리  
4. **UML 다이어그램 작성(필요 시)**  
   - 클래스 다이어그램, 시퀀스 다이어그램, 활동 다이어그램 등  

#### 4.2.3 개발(코드 구현)
1. **코드 작성**  
   - 브랜치: `feature/{usecase_name}`  
   - 공통 코드(`develop` 브랜치)에 있는 기능 + 유즈케이스별 추가/변경 사항을 구현  
2. **개발환경 설정**  
   - 로컬 빌드, 테스트 환경 세팅  
   - 필요한 경우 Docker, VM, 컨테이너 설정  

#### 4.2.4 테스트
- **단위 테스트(Unit Test)**: 기능 클래스/메서드 단위  
- **통합 테스트(Integration Test)**: 모듈 간 연동, DB/API 연동  
- **시스템 테스트(System Test)**: 전체 시스템 관점  
- **인수 테스트(Acceptance Test)**: 실제 시나리오 기반으로 최종 검증  

### 4.3 통합 및 전체 시스템 테스트
1. **브랜치 병합(Merge)**  
   - 기능 단위 완료 시, Pull Request(MR)를 통해 `feature/{usecase_name}` → `develop`  
   - 코드 리뷰 및 자동화 테스트(CI) 통과 후 최종 병합  
2. **전체 통합 테스트**  
   - 시스템 레벨에서 모든 유즈케이스가 올바르게 동작하는지 검증  
   - 다른 유즈케이스와 충돌(Conflict) 여부, 종속성 문제 확인  
3. **프로덕션(또는 스테이징) 환경 배포**  
   - 특정 시점 버전을 태깅(Tag)하여 빌드 & 배포  
   - 모니터링/로깅을 통해 지속적으로 품질 관리  

# 브랜치 전략 및 공통코드 관리

## 1. 브랜치 전략 개요
- **중앙 브랜치**: `develop`  
  - **공통 코드**와 **통합된 기능**을 유지하는 주요 브랜치  
- **기능 브랜치**: `feature/{usecase_name}`  
  - 유즈케이스별로 분리 개발  
  - 개발 완료 후 `develop`에 병합(Merge)  

### 예시 흐름
1. `develop` 브랜치에 **공통 코드**(프로젝트 기본 구조, 설정, 공용 라이브러리, DB 연결 등) 존재  
2. 각 유즈케이스를 개발할 때, `develop`에서 **새로운 기능 브랜치**(`feature/login` 등) 생성  
3. 필요한 **공통 기능** 변경/추가가 있으면, 해당 브랜치에서 수정 → `develop` 반영  
   - 공통 코드가 다른 유즈케이스와 충돌을 일으키지 않도록 주의  
4. 기능 개발이 완료되면, Pull Request(MR)를 작성하여 코드 리뷰 후 `develop`으로 병합  

## 2. 공통 코드와 유즈케이스별 코드 분리 전략
- **폴더/패키지 구조**  
  - 예:  
    ```
    src
    ├── main
    │   ├── common      # 공통 로직, 유틸, 예외 처리
    │   ├── moduleA     # 유즈케이스 A 관련 코드
    │   ├── moduleB     # 유즈케이스 B 관련 코드
    │   └── ...
    └── test
        ├── common
        └── moduleA
        └── moduleB
        └── ...
    ```
- **소규모 프로젝트**라면 단일 프로젝트 구조 내에서 패키지로 구분  
- **대규모 프로젝트**라면 **멀티 모듈**(예: Gradle Multi-Module, Maven Multi-Module)로 구성 가능  

## 3. 통합(Integration) 주기
- **단위 기능**(유즈케이스) 개발이 완료될 때마다, 빠른 주기로 `develop`에 병합  
- 병합 시 **자동화 테스트(CI)**가 동작해 빌드 및 테스트를 확인  
- 통합 후 **전체 기능**(기존 유즈케이스 + 새 유즈케이스)이 함께 동작하는지 **검증**  

## 4. 유의할 점
- **공통 코드 변경 시** → 다른 유즈케이스 브랜치들과의 **충돌**을 미리 파악  
- **릴리즈(Release) 브랜치**를 별도로 두어, 안정화 작업 후 제품 배포할 수도 있음(Git Flow)  
- PR(MR) 작성 시, 변경 내용과 테스트 방법을 명확히 기재 → 팀원의 리뷰 효율성 증대  

---

# 결론

- **1~3단계**에서 요구사항과 유즈케이스를 정의하고 우선순위를 정한 뒤,  
- **4단계**에서 프로젝트 기본 구성을 확립합니다.  
- 이후 **유즈케이스별 브랜치**를 생성하여, 공통 코드를 기반으로 필요한 추가 코드를 작성하고 테스트합니다.  
- 주기적으로 `develop` 브랜치로 병합하여 **통합 테스트**와 **전체 시스템 테스트**를 수행함으로써,  
  **리스크를 줄이고 단계적으로 프로젝트를 완성**해 나갈 수 있습니다.  

이를 통해 **유즈케이스 단위 개발**을 쉽고 체계적으로 관리하고,  
**공통 코드**와 **개별 기능 코드**를 분리해 유지보수성과 협업 효율을 높이는 전략을 구현할 수 있습니다.
