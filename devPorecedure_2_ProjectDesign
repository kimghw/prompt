### 1 프로젝트 구성 지침
1. **개발환경 결정**  
   - IDE, 에디터, OS, 프레임워크 버전, 빌드 도구(Maven/Gradle/npm 등)  
2. **프로젝트 아키텍처 결정**  
   - 느슨한 결합(Loose Coupling) : 모듈 간 직접적인 의존성 대신 이벤트/메시지 기반 통신
   - 높은 응집성(High Cohesion) : 각 모듈은 명확한 단일 책임 원칙 준수
   - 확장 가능성 : 수평적 확장이 가능은 stateless 설계
   - 장애 격리 : 한 모듈의 장애가 전체 시스템에 영향을 주지 않도록 설계
3. **관련 라이브러리, DB, API 결정**  
   - 예) Spring Boot, React, MySQL, Redis, 외부 결제 API 등  
   - 빌드/패키지 도구 설정(Maven, Gradle 등)  
4. 데이터 흐름 표준화
   - 입력 : 표준화된 메시지 포맷(JSON Schema)
   - 처리 : 각 모듈은 독립적으로 처리 후 결과 이벤트 발생
   - 출력 : 다음 모듈이 소비할 수 있는 표준 이벤트
5. **모듈 간 통신 설계**
   - 비동기 메시징 : Kafka/RabbitMQ를 통한 이벤트 기반 통신
   - API Gateway : 외부 요청을 위한 단일 진입점(선택사항)
   - 모듈 간 인터페이스 명확화


# 표준 이벤트 정의 예시
DocumentIngested:
  document_id: string
  source_type: enum[email, pdf, web]
  storage_path: string
  metadata: object

TextExtracted:
  document_id: string
  chunks: array[ChunkData]
  extraction_method: string

#### 2 설계 및 모델링 원칙
1. **모듈 간 이벤트 기반 아키텍쳐**  
   - 이벤트 중심 설계 원칙
   - 데이터 저장 및 참조 방식 
   - 모듈간 완전한 독립성 보장
2.  공유 저장소 전략:
  1.2.1.  (선택시)Object Storage (S3/MinIO):
     - 원본 문서 (PDF, HTML 등)
     - 추출된 텍스트 청크
     - 임베딩 벡터 (대용량)  
  1.2.2.  (선택시)메타데이터 DB (PostgreSQL):
     - 문서 상태 (processing, completed, failed)
     - 문서 메타정보 (크기, 생성일, 소유자)
     - 처리 이력
  1.2.3. 이벤트 스토어 (Kafka):
     - 이벤트 히스토리
     - 처리 상태 변경 이벤트
     - 에러 이벤트
3. 전체 파이프라인 이벤트 흐름(예시)
graph LR
    A[PDF Upload] -->|document.ingested| B[Kafka]
    B -->|consume| C[Processing Module]
    C -->|text.extracted| B
    B -->|consume| D[Embedding Module]
    D -->|embedding.created| B
    B -->|consume| E[Storage Module]
    E -->|document.indexed| B
    B -->|consume| F[Search Module Ready]

### 3 시나리오별/모듈별 개발 계획
#### 2.2.1 우선순위 결정 기준
- 비즈니스 가치 : 사용자에게 즉시 가치를 제공하는가?
- 기술적 의존성 : 다른 기능의 전제조건인가?
- 구현 난이도 :빠르게 구현하여 검증 가능한가?
- 리스크 : 기술적 불확실성이 높은가?
#### 2.2.2 개발 진행 방식
- 모듈별 단위 개발 하고 매 모듈 종료 시 테스트
- 빠르게 동작하는  MVP를 만들고, 점진적으로 기능을 확장하면서 확보

#### 2.2.3 개발 단계 정의 
Phase 1 - Foundation (주요 인프라):
  목표: 핵심 인프라 및 공통 컴포넌트 구축
  산출물: 
    - 기본 아키텍처 구현
    - 공통 라이브러리
    - 개발/테스트 환경  
Phase 2 - Core Features (핵심 기능):
  목표: 최소 기능 제품(MVP) 구현
  산출물:
    - 핵심 비즈니스 로직
    - 기본 API
    - 필수 UI/UX
(선택시) Phase 3 - Enhancement (기능 확장):
  목표: 사용성 및 성능 개선
  산출물:
    - 추가 기능
    - 성능 최적화
    - 사용자 경험 개선
(선택시) Phase 4 - Operation (운영 준비):
  목표: 프로덕션 준비
  산출물:
    - 모니터링/로깅
    - 보안 강화
    - 운영 도구

### 3 시나리오별/모듈별 설계 순서
1. **모듈 독립성 보장**
   - 인터페이스 설계 원칙 준수
   - 데이터 교환 표준(불변, 완결적, 버전 관리, 표준 포맷)
2. **모듈 정의 및 책임할당**  
   - 유즈케이스 분석을 통한 모듈 도출
   - 모듈의 핵심 책임 정의 및 모듈 간 경계 설정
3. **이벤트 및 메시지 정의**  
4. **API인터페이스 설계**  
5. **DTO(Data Transfer Object) 설계**  
6. **도메인 모델 정의**
7. **데이터베이스 스키마 설계**
8. **저장소 인터페이스 정의**
9. **유즈케이스 구현 설계**
10. **에러 처리 전략 수립**
11. **모듈 통합 포인트 정의**
12. **설정 및 환경 구성**
13. ** 설계 검증 체크리스트, 설계문서 작성**

## 모듈 설계 문서

### 1. 개요
- 모듈 목적
- 주요 기능
- 제약사항

### 2. 아키텍처
- 컴포넌트 다이어그램
- 시퀀스 다이어그램
- 데이터 흐름도

### 3. 인터페이스
- API 명세
- 이벤트 스키마
- 데이터 모델

### 4. 구현 가이드
- 개발 환경 설정
- 코딩 컨벤션
- 테스트 전략

## 설계 순서 요약
graph TD
    A[1. 모듈 정의] --> B[2. 관계 분석]
    B --> C[3. 이벤트 정의]
    C --> D[4. API 설계]
    D --> E[5. DTO 설계]
    E --> F[6. 도메인 모델]
    F --> G[7. DB 스키마]
    G --> H[8. 저장소 인터페이스]
    H --> I[9. 유즈케이스 구현]
    I --> J[10. 에러 처리]
    J --> K[11. 통합 포인트]
    K --> L[12. 환경 구성]
    L --> M[13. 설계 검증]
    M --> N[14. 문서화]



### 4 모듈 디자인 지침
1. **모듈 독립성 보장**
